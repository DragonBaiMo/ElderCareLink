# 《基于 SpringBoot 的关爱空巢老人管理系统》

开发流程说明（IPO）

> 说明：本说明按 **P0～P9** 拆解整个开发过程，每个阶段都用 **Input → Process → Output** 描述，让本科生照着也能从 0 拉到能跑。

---

## P0 需求理解（需求澄清与范围收敛）

### Input（输入）

* 开题报告全文（研究背景、意义、主要内容、方法等）
* 选题动因与国内外研究综述
* 目录框架（六章结构）
* 前两份文档：PDR、PRD
* 指导老师对功能范围的意见（如“能演示即可”“先保证主线闭环”）

### Process（过程）

1. **梳理业务目标**

   * 抽取关键词：空巢老人、健康管理、志愿者探访、社区公告、数据统计等
   * 明确系统只做“信息管理 + 关爱记录”，不做智能诊断、不做支付、不做大模型

2. **明确角色与使用场景**

   * 角色：管理员、志愿者、家属（可选）
   * 结合 PRD 场景，整理 3～5 条核心演示流程（建档、记健康、记探访、发公告、看统计）

3. **功能优先级确认**

   * 根据 Must / Should / Could 列出清单，确认：

     * 答辩现场必须演示哪些页面
     * 哪些功能有时间就做，来不及就降级

4. **形成需求清单与约束**

   * 记录所有“禁止事项”：不搞微服务、不搞支付、不搞复杂推荐
   * 把系统定位锁死为：**单体 Web 应用 + 本地运行**

### Output（输出）

* 《需求确认记录》：列清楚要做什么 / 不做什么
* 功能列表 + 优先级标注（Must/Should/Could 表格）
* 角色 & 场景说明（可直接放进论文第二章）

---

## P1 后端初始化（SpringBoot 工程搭建）

### Input（输入）

* 确认后的技术栈：Java + SpringBoot + MySQL + Maven
* 数据库连接信息（本地 MySQL）
* 开发工具：IDEA、JDK、Maven 安装完成

### Process（过程）

1. **创建 SpringBoot 工程**

   * 使用 IDEA 新建 Spring Initializr 项目
   * 选择依赖：`spring-boot-starter-web`、`spring-boot-starter-data-jpa` 或 MyBatis、`spring-boot-starter-validation`、`spring-boot-starter-test`

2. **配置基础结构**

   * 规划包结构：

     * `controller`：接口层
     * `service`、`service.impl`：业务层
     * `repository` 或 `mapper`：持久层
     * `entity`：实体类
     * `config`：配置类
     * `common`：通用返回、异常处理等
   * 编写 `application.yml`：端口、数据库、JPA/MyBatis 设置

3. **编写启动入口**

   * 编写 `@SpringBootApplication` 主类
   * 启动项目，确认能在浏览器访问一个测试接口（例如 `/hello` 返回字符串）

### Output（输出）

* 可正常启动的 SpringBoot 空项目
* 标准化的包结构与配置文件
* 一份简要的《后端初始化说明》（写入论文或附录）

---

## P2 数据库设计（表结构与关系确认）

### Input（输入）

* PDR 中的“数据库概要设计”部分
* 各模块的实体对象需求：用户、老人、健康记录、探访记录、公告、字典/配置
* MySQL 环境已安装

### Process（过程）

1. **逻辑模型整理**

   * 用表格或 ER 图梳理主要实体：

     * `t_user`、`t_elder`、`t_health_record`、`t_visit_record`、`t_announcement`、`t_dict` 等
   * 标记字段类型、主键、外键关系（例如 `t_health_record.elder_id → t_elder.id`）

2. **规范字段设计**

   * 保证每张表有：

     * 主键 `id`
     * 创建时间 `create_time`
     * 可选的状态字段 `status`
   * 避免不必要的过度拆表，保持表结构简单清晰

3. **编写建表脚本**

   * 使用标准 SQL 编写 `CREATE TABLE` 语句
   * 在本地 MySQL 中执行以验证语法与关系正确

4. **在后端映射实体**

   * 根据表结构定义 `entity` 实体类
   * 配置 JPA 注解或 MyBatis 映射

### Output（输出）

* 完整的数据库建表脚本（.sql 文件，可附在论文）
* ER 图或字段设计文档
* 与数据库对齐的后端实体类代码骨架

---

## P3 公共模块开发（通用能力搭建）

> 这一阶段把所有“到处要用”的共性东西先弄出来，后面业务模块就轻松许多。

### Input（输入）

* 已初始化的 SpringBoot 项目
* 已完成的实体类和数据库设计
* 功能清单中通用需求：登录、统一返回、异常处理等

### Process（过程）

1. **统一返回结果封装**

   * 定义通用响应类，如 `Result<T>`：包含 `code`、`message`、`data`
   * 在 Controller 中统一返回该结构，方便前端解析

2. **全局异常处理**

   * 编写 `@ControllerAdvice` + `@ExceptionHandler`
   * 对常见异常（校验失败、参数错误、业务异常）统一转为友好的响应

3. **基础登录认证（简化版）**

   * 实现最简单的账号密码登录：

     * `POST /api/auth/login` 接口
     * 通过数据库校验账号密码（密码存储使用加密）
   * 使用 Session 或简易 Token（如 JWT）做登录态管理（二选一即可）

4. **简易权限控制**

   * 通过用户角色字段（管理员 / 志愿者 / 家属）控制接口访问
   * 方式可以是简单的拦截器检查角色，不必做复杂 RBAC

5. **通用分页与条件查询支持**

   * 封装分页参数（页码、页大小）对象
   * 封装分页返回结构，方便列表页面统一使用

### Output（输出）

* 通用响应封装类、异常处理类、登录认证代码
* 可以通过接口文档或 Postman 完成一套“登录 + 基础接口调用”的联调
* 一份简单的《公共模块设计说明》（可并入 PDR/论文）

---

## P4 核心业务模块开发（老人/健康/探访/公告等）

> 这里是整个系统的心脏，答辩时 90% 演示都靠它。

### Input（输入）

* 已实现的公共模块（登录、返回、异常处理等）
* 数据库中与业务相关的表
* 功能清单中标记为 Must / Should 的核心功能点

### Process（过程）

将核心业务拆成若干小模块，逐个完成 **Controller → Service → Repository → 前端接口对接（后续）**。

1. **用户与角色管理模块（简化版）**

   * 实现用户列表查询、创建、修改接口（仅管理员可用）
   * 用于给志愿者/家属开账号

2. **老人信息管理模块**

   * 接口：

     * 新增老人：`POST /api/elders`
     * 查询列表：`GET /api/elders`（支持条件分页）
     * 查看详情：`GET /api/elders/{id}`
     * 修改信息：`PUT /api/elders/{id}`
     * 注销/冻结：`DELETE` 或 `PATCH /api/elders/{id}/disable`
   * 业务逻辑：

     * 新增时校验必填项（姓名、地址、紧急联系人等）
     * 注销只做状态标记，不删除数据

3. **健康信息记录模块**

   * 接口：

     * 新增记录：`POST /api/health-records`
     * 按老人查询列表：`GET /api/elders/{id}/health-records`
     * 按时间范围过滤（Should）
   * 业务逻辑：

     * 校验老人存在
     * 校验指标范围（例如体温 34～42 之间）
     * 可在 Service 中简单判定“是否超出阈值”并返回提示标志

4. **志愿者与探访记录模块**

   * 接口：

     * 新增探访记录：`POST /api/visit-records`
     * 按志愿者查询：`GET /api/visit-records?volunteerId=...`
     * 按老人查询：`GET /api/elders/{id}/visit-records`
   * 业务逻辑：

     * 绑定当前登录用户作为志愿者 ID
     * 记录探访时间、方式、内容、老人状态、后续建议
     * 提供基础统计：某志愿者的服务次数、某老人被探访次数等

5. **社区公告模块**

   * 接口：

     * 新增公告：`POST /api/announcements`
     * 公告列表：`GET /api/announcements`（默认只返回已发布）
     * 公告详情：`GET /api/announcements/{id}`
     * 状态更新：`PUT /api/announcements/{id}/status`（草稿/已发布/下架）
   * 业务逻辑：

     * 新增时记录发布人 ID
     * 状态管理控制可见性

6. **数据统计与简易报表模块**

   * 接口：

     * 老人总数/按健康等级统计：`GET /api/statistics/elders`
     * 志愿服务次数统计：`GET /api/statistics/visits`
   * 返回结构设计为简单的键值对列表，方便前端画图

7. **字典与配置模块（可简化）**

   * 直接在后台用字典表维护居住类型、健康等级等
   * 提供读取接口：`GET /api/dicts/{type}` 供前端下拉选择

### Output（输出）

* 一套完整的后端业务接口，覆盖 Must/Should 功能
* 通过 Postman 可以串起一条完整业务链条：

  * 登录 → 新增老人 → 录健康记录 → 录探访 → 发公告 → 查统计
* 接口文档（可使用 Swagger 或 Markdown 说明）

---

## P5 前端初始化（Vue 工程搭建）

### Input（输入）

* 确认前端技术栈：Vue2/Vue3 + Axios + UI 组件库
* 已完成的后端基础接口（至少登录接口可用）
* Node.js 与包管理器（npm/yarn/pnpm）安装完成

### Process（过程）

1. **创建前端项目**

   * 使用 CLI 创建 Vue 工程（如 Vue CLI 或 Vite）
   * 配置项目结构：

     * `views`：页面
     * `components`：通用组件
     * `router`：路由配置
     * `store`（可选）：状态管理
     * `api`：封装请求方法

2. **引入 UI 组件库**

   * 安装 Element UI / Element Plus（任选其一）
   * 全局注册基础组件，统一风格

3. **配置路由与基础布局**

   * 定义登录页路由 `/login`
   * 定义主布局（含侧边菜单 + 顶部导航）
   * 预留菜单入口：老人管理、健康记录、探访记录、公告管理、统计报表等

4. **Axios 封装**

   * 设置基础 URL（指向后端地址）
   * 配置请求拦截器：携带 Token / Session 信息
   * 配置响应拦截器：统一处理错误码与提示

### Output（输出）

* 可运行的 Vue 前端骨架项目
* 可以通过界面访问登录页，登录成功后进入主框架（空白菜单也行）
* 前端项目结构清晰，可支撑后续页面开发

---

## P6 用户端开发（志愿者 / 家属视角）

> “用户端”主要是志愿者/家属的日常操作视图，偏业务操作，不偏管理。

### Input（输入）

* 已完成的后台接口（特别是探访记录、公告、老人信息查询）
* 前端基础框架与路由配置

### Process（过程）

1. **登录与角色识别**

   * 登录后获取用户角色信息
   * 若为志愿者/家属，则进入“用户端首页”（与管理员菜单区别）

2. **志愿者端页面开发**

   * 「我的老人列表」页面：

     * 展示与当前志愿者关联的老人（可以简化为显示所有老人）
     * 支持按姓名、健康等级筛选
   * 「探访记录填写」界面：

     * 选择老人、填写服务内容、老人状态、时间（默认当前时间）
     * 调用后端新增探访记录接口
   * 「我的探访记录」页面：

     * 展示当前志愿者的探访历史列表
     * 支持简单查询（按时间、老人）

3. **家属端页面（Should/Could）**

   * 「绑定老人信息」（可由管理员先在后台配好关系）
   * 「老人概况」页面：

     * 展示老人的基本信息
     * 展示最近几条健康记录与探访记录摘要

4. **公告浏览**

   * 公告列表页：展示已发布公告
   * 公告详情页：展示全文内容

### Output（输出）

* 志愿者可通过前端完成：

  * 登录 → 查看老人 → 填写探访记录 → 查看自己记录
* 若实现家属端，则家属可：

  * 登录 → 查看老人基本信息及最近关爱情况

---

## P7 管理端开发（管理员视角）

> 管理端 = 操作一大堆表格的那个人，方便老师一眼看出“你有在做管理系统”。

### Input（输入）

* 已完成的后端管理接口
* 前端项目已有基础布局与路由
* Must/Should 功能中需要管理员操作的部分

### Process（过程）

1. **管理员菜单设计**

   * 左侧菜单规划：

     * 仪表盘（统计概览）
     * 老人信息管理
     * 健康记录管理
     * 志愿者与探访管理
     * 公告管理
     * 基础数据/字典管理（可选）

2. **老人信息管理页面**

   * 列表页：表格展示老人信息，支持分页与条件查询
   * 新增/编辑弹窗：表单 + 校验
   * 注销操作：按钮 + 二次确认对话框

3. **健康记录管理页面**

   * 管理员视角的健康记录列表（可按老人筛选）
   * 新增记录页面（也可通过老人详情界面录入）
   * 简单提示：当指标超出阈值时，列表中标红字段

4. **探访记录管理页面**

   * 展示全部探访记录，支持按志愿者、老人、时间筛选
   * 可选：在详情页展示“服务内容 + 老人状态 + 建议”

5. **公告管理页面**

   * 新增公告表单：标题、内容、类型、状态
   * 公告列表：显示状态、发布时间
   * 状态切换：草稿 → 已发布 → 下架

6. **统计报表页面**

   * 简单统计卡片：

     * 老人总数
     * 本月新增探访记录数
   * 图表（使用 ECharts 等前端库）：

     * 健康等级分布图
     * 志愿者服务次数排行图（可选）

### Output（输出）

* 管理员能通过前端完成：

  * 建档 → 管理老人信息
  * 查看并维护健康记录、探访记录
  * 发布公告与查看统计图表
* 一套适合作为答辩演示的“后台管理界面”

---

## P8 联调测试（功能走通与缺陷修复）

### Input（输入）

* 已完成的前后端功能模块
* 接口文档或前后端约定的 API 说明
* 测试数据（模拟若干老人、志愿者、记录等）

### Process（过程）

1. **前后端联调**

   * 逐个页面核对请求 URL、请求参数、响应格式
   * 使用浏览器开发者工具或 Postman 辅助排查问题
   * 修复因字段名不一致、返回结构不统一等造成的错误

2. **功能流程测试**

   * 覆盖核心演示流程：

     * 管理员：登录 → 新增老人 → 新增健康记录 → 查看统计
     * 志愿者：登录 → 填写探访记录 → 查看自己的记录
     * 公告发布：管理员发布公告 → 志愿者端查看公告

3. **异常与边界测试**

   * 错误账号密码登录
   * 必填项不填时提交表单
   * 删除/注销数据时的二次确认
   * 简单并发操作：连续点击保存按钮等

4. **记录缺陷与修复**

   * 用简单表格列出“问题描述 → 复现步骤 → 原因 → 解决方案”
   * 解决后重新回归测试

### Output（输出）

* 一套在本地环境能稳定运行、无明显致命缺陷的系统
* 简单的《测试记录表》与《问题修复清单》（可附在论文或答辩资料中）

---

## P9 打包部署（本地演示环境准备）

> 不搞云，不搞 Docker，全程“本地 MVP 能跑就行”。

### Input（输入）

* 已通过联调测试的后端项目与前端项目
* 目标演示环境信息（例如实验室电脑 / 自己笔记本，Windows）

### Process（过程）

1. **后端打包**

   * 使用 Maven 进行打包：`mvn clean package`
   * 生成 `jar` 文件
   * 准备好 `application.yml`，确保数据库地址为本地或可访问服务器

2. **前端构建**

   * 使用构建命令打包前端项目（如 `npm run build`）
   * 生成静态资源（dist 目录）
   * 可选方案：

     * 方案 A：通过 Nginx 或本地静态服务托管
     * 方案 B：将打包后的前端放入 SpringBoot 的 `static` 或 `templates` 目录中，简化部署

3. **本地演示脚本**

   * 编写一份简单的“启动步骤”文档：

     1. 启动 MySQL，确认数据库已导入
     2. 双击运行 `java -jar xxx.jar` 或在 IDEA 中运行主类
     3. 打开浏览器访问 `http://localhost:8080`（或具体端口）
   * 预置演示账号和密码（例如：

     * 管理员：admin / 123456
     * 志愿者：vol01 / 123456）

4. **模拟答辩彩排**

   * 按预设演示流程走一遍：

     * 登录 → 简单介绍系统结构 → 演示关键功能 → 展示统计与数据
   * 确认每一步都有数据、有页面、有话可讲

### Output（输出）

* 可直接在本地运行并演示的系统包（jar + 前端静态资源 + SQL）
* 《系统部署与运行说明》文档
* 一套清晰的现场演示流程脚本，确保紧张的时候不至于大脑短路
